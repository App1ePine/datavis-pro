// ============================================================================
// models/dataset.rs - 数据模型定义
// ============================================================================
// 这个文件定义了应用中使用的数据结构
// 这些结构体用于在 Rust 后端和前端之间传递数据

// 导入 serde 库，用于序列化和反序列化
// 序列化：将 Rust 数据结构转换为 JSON（发送给前端）
// 反序列化：将 JSON 转换为 Rust 数据结构（接收前端数据）
use serde::{Deserialize, Serialize};

// ============================================================================
// 数据集元信息结构体
// ============================================================================
/// DatasetInfo - 数据集的元信息
///
/// 这个结构体包含了数据集的基本信息，但不包含实际的数据行
/// 用于在前端显示数据集列表和基本统计信息
///
/// 派生宏说明：
/// - Debug: 允许使用 println!("{:?}", dataset_info) 打印调试信息
/// - Clone: 允许复制这个结构体（因为它不包含大量数据）
/// - Serialize: 可以转换为 JSON 发送给前端
/// - Deserialize: 可以从 JSON 转换回 Rust 结构体
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatasetInfo {
    /// 数据集唯一标识符
    ///
    /// 使用 UUID（通用唯一识别码）生成，例如：
    /// "550e8400-e29b-41d4-a716-446655440000"
    ///
    /// pub 关键字表示这个字段是公开的，可以被其他模块访问
    pub id: String,

    /// 文件名
    ///
    /// 从文件路径中提取的文件名，例如：
    /// "sales_data.csv" 或 "report.xlsx"
    pub name: String,

    /// 总行数
    ///
    /// usize 是 Rust 中表示大小的无符号整数类型
    /// 在 64 位系统上是 64 位，在 32 位系统上是 32 位
    pub rows: usize,

    /// 列信息列表
    ///
    /// Vec<T> 是 Rust 中的动态数组（类似于其他语言的 ArrayList 或 List）
    /// 这里存储了每一列的详细信息
    pub columns: Vec<ColumnInfo>,

    /// 原始文件路径
    ///
    /// 完整的文件系统路径，例如：
    /// "/Users/username/Documents/data.csv"
    pub file_path: String,

    /// 导入时间
    ///
    /// ISO 8601 格式的时间字符串，例如：
    /// "2024-01-22T10:30:00Z"
    pub imported_at: String,
}

// ============================================================================
// 列信息结构体
// ============================================================================
/// ColumnInfo - 单个列的信息
///
/// 描述数据集中一列的详细信息，包括名称、类型和空值统计
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ColumnInfo {
    /// 列名
    ///
    /// 例如："姓名"、"年龄"、"销售额" 等
    pub name: String,

    /// 数据类型
    ///
    /// Polars 支持的数据类型字符串表示，例如：
    /// - "Int64": 64 位整数
    /// - "Float64": 64 位浮点数
    /// - "String": 字符串（在 Polars 中称为 Utf8）
    /// - "Boolean": 布尔值
    /// - "Date": 日期
    /// - "Datetime": 日期时间
    pub dtype: String,

    /// 空值数量
    ///
    /// 这一列中有多少个空值（null/missing values）
    /// 用于数据质量评估
    pub null_count: usize,
}

// ============================================================================
// 数据集数据结构体
// ============================================================================
/// DatasetData - 数据集的实际数据（分页）
///
/// 这个结构体用于传输实际的数据行
/// 为了性能考虑，通常只传输一部分数据（分页）
#[derive(Debug, Serialize, Deserialize)]
pub struct DatasetData {
    /// 列名列表
    ///
    /// 按顺序存储所有列的名称
    /// 例如：["姓名", "年龄", "城市"]
    pub columns: Vec<String>,

    /// 数据行
    ///
    /// 二维数组，外层是行，内层是列
    /// Vec<Vec<serde_json::Value>> 表示：
    /// - 外层 Vec: 多行数据
    /// - 内层 Vec: 一行中的多个值
    /// - serde_json::Value: 可以是任何 JSON 类型（数字、字符串、null 等）
    ///
    /// 例如：
    /// [
    ///   ["张三", 25, "北京"],
    ///   ["李四", 30, "上海"],
    ///   ["王五", null, "广州"]
    /// ]
    pub rows: Vec<Vec<serde_json::Value>>,

    /// 总行数
    ///
    /// 数据集的总行数（不是当前返回的行数）
    /// 用于前端实现分页功能
    ///
    /// 例如：如果数据集有 10000 行，但只返回前 100 行
    /// 那么 rows.len() = 100，但 total_rows = 10000
    pub total_rows: usize,
}

// ============================================================================
// 数据流说明
// ============================================================================
//
// 1. 文件导入时：
//    - Rust 读取 CSV/Excel 文件
//    - 使用 Polars 解析为 DataFrame
//    - 创建 DatasetInfo（提取元信息）
//    - 将 DataFrame 存储在内存中
//    - 返回 DatasetInfo 给前端
//
// 2. 前端请求数据时：
//    - 前端调用 get_dataset_data(id, offset, limit)
//    - Rust 从 DataFrame 中切片数据
//    - 将数据转换为 DatasetData 结构体
//    - 序列化为 JSON 返回给前端
//
// 3. 前端显示数据：
//    - 接收 JSON 数据
//    - TypeScript 类型系统确保类型安全
//    - ag-Grid 使用这些数据渲染表格
//
// ============================================================================

// ============================================================================
// JSON 序列化示例
// ============================================================================
//
// DatasetInfo 序列化为 JSON：
// {
//   "id": "550e8400-e29b-41d4-a716-446655440000",
//   "name": "sales_data.csv",
//   "rows": 1000,
//   "columns": [
//     {
//       "name": "产品名称",
//       "dtype": "String",
//       "null_count": 0
//     },
//     {
//       "name": "销售额",
//       "dtype": "Float64",
//       "null_count": 5
//     }
//   ],
//   "file_path": "/path/to/sales_data.csv",
//   "imported_at": "2024-01-22T10:30:00Z"
// }
//
// DatasetData 序列化为 JSON：
// {
//   "columns": ["产品名称", "销售额"],
//   "rows": [
//     ["产品A", 1000.5],
//     ["产品B", 2000.0],
//     ["产品C", null]
//   ],
//   "total_rows": 1000
// }
//
// ============================================================================

// ============================================================================
// 列统计信息结构体
// ============================================================================
/// ColumnStats - 列的统计信息
///
/// 包含列的基础统计量、分位数和数据质量指标
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ColumnStats {
    /// 列名
    pub name: String,

    /// 数据类型
    pub dtype: String,

    /// 总数目
    pub total_count: usize,

    /// 缺失值数量
    pub null_count: usize,

    /// 唯一值数量
    pub unique_count: usize,

    /// 最大值（仅数值类型）
    pub max: Option<f64>,

    /// 最小值（仅数值类型）
    pub min: Option<f64>,

    /// 平均值（仅数值类型）
    pub mean: Option<f64>,

    /// 标准差（仅数值类型）
    pub std: Option<f64>,

    /// 25% 分位值（仅数值类型）
    pub q25: Option<f64>,

    /// 50% 分位值/中位数（仅数值类型）
    pub q50: Option<f64>,

    /// 75% 分位值（仅数值类型）
    pub q75: Option<f64>,

    /// 最早时间（仅日期时间类型）
    pub min_datetime: Option<String>,

    /// 最晚时间（仅日期时间类型）
    pub max_datetime: Option<String>,

    /// 时间跨度（仅日期时间类型，单位：天）
    pub datetime_range_days: Option<f64>,

    /// True 数量（仅布尔类型）
    pub true_count: Option<usize>,

    /// False 数量（仅布尔类型）
    pub false_count: Option<usize>,
}
